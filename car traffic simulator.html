<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Car Scene - Mobile Controls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Prevent scrollbars */
            background-color: #a0d7e6;
            /* Light sky blue background */
            font-family: 'Press Start 2P', cursive, sans-serif;
            /* A retro arcade font for style */
            /* Prevent default touch behaviors like pull-to-refresh or selection */
            overscroll-behavior: none;
            touch-action: none;
            /* For pointer events, might help on some devices */
        }
        canvas {
            display: block;
            /* Remove annoying space below canvas */
        }
        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            /* For progress text */
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            gap: 15px;
        }
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
            /* Disable interaction after fading */
        }
        #loading-text {
            font-size: 1em;
        }
        #loading-progress {
            font-size: 0.8em;
        }
        /* --- UI Elements --- */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            /* White text */
            text-shadow: 1px 1px 3px black;
            /* Black shadow for readability */
            z-index: 50;
            font-size: 1.5em;
            /* Slightly larger font */
            pointer-events: none;
            /* Let clicks pass through */
        }
        #score {
            margin-bottom: 5px;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            /* Bright red */
            font-size: 4em;
            /* Large text */
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 5px black;
            /* Stronger shadow */
            display: none;
            /* Hidden initially */
            z-index: 101;
            /* Above everything else */
            pointer-events: auto;
            /* Enable clicks on restart button */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        #restart-button {
            background-color: #21c60ffc;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.4em;
            /* Relative to parent font-size */
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s ease;
        }
        #restart-button:hover {
            background-color: #0056b3;
        }
        /* --- Mobile Control Buttons --- */
        .control-button {
            position: absolute;
            bottom: 20px;
            /* Position from bottom */
            width: 80px;
            /* Button width */
            height: 80px;
            /* Button height */
            background-color: rgba(255, 255, 255, 0.3);
            /* Semi-transparent white */
            border: 2px solid rgba(0, 0, 0, 0.5);
            /* Darker border */
            border-radius: 50%;
            /* Circular buttons */
            z-index: 60;
            /* Above canvas, below game over */
            display: flex;
            /* For centering arrow inside */
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            /* Arrow size */
            color: rgba(0, 0, 0, 0.7);
            /* Arrow color */
            cursor: pointer;
            /* Indicate clickable */
            /* Prevent text selection on tap */
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            /* Prevent iOS tap highlight */
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            /* Allow interaction */
        }
        /* Style for when button is pressed */
        .control-button:active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        #left-button {
            left: 650px;
            /* Position left button */
        }
        #right-button {
            right: 650px;
            /* Position right button */
        }
        /* --- Alert Message --- */
        #alert-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 99;
            border: 4px solid #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
        /* --- Overspeed Alert --- */
        #overspeed-alert {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 200, 0, 0.95), rgba(255, 100, 0, 0.95));
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 100;
            border: 3px solid #ff6600;
            box-shadow: 0 0 15px rgba(255, 100, 0, 0.8);
            animation: overspeedPulse 0.3s infinite;
        }
        @keyframes overspeedPulse {
            0%,
            100% {
                background: linear-gradient(135deg, rgba(255, 200, 0, 0.95), rgba(255, 100, 0, 0.95));
            }
            50% {
                background: linear-gradient(135deg, rgba(255, 50, 0, 0.95), rgba(255, 0, 0, 0.95));
            }
        }
        /* --- Speedometer --- */
        #speedometer-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 180px;
            height: 180px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(0, 0, 0, 0.6));
            border-radius: 50%;
            border: 4px solid #c41e3a;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(0, 0, 0, 0.4);
            z-index: 65;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
        }
        #speedometer-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #speed-value {
            font-size: 2.2em;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-top: 10px;
        }
        #speed-unit {
            font-size: 0.9em;
            color: #cccccc;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        #speedometer-needle {
            position: absolute;
            width: 4px;
            height: 70px;
            background: linear-gradient(to top, #ff0000, #ffff00);
            transform-origin: bottom center;
            bottom: 50%;
            left: 50%;
            margin-left: -2px;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.8);
            transition: transform 0.05s ease-out;
        }
        #speedometer-scale {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        .speed-marker {
            position: absolute;
            width: 2px;
            height: 12px;
            background-color: #fff;
            left: 50%;
            transform-origin: 50% 75px;
        }
        #speedometer-label {
            position: absolute;
            top: 5px;
            font-size: 0.75em;
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        /* --- End Speedometer --- */
        /* --- Racing Lines --- */
        #racing-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
            display: none;
        }
        .racing-line {
            position: absolute;
            background: linear-gradient(to bottom, rgba(255, 200, 0, 0.8), rgba(255, 200, 0, 0));
            pointer-events: none;
        }
        /* --- End Racing Lines --- */
        /* Import Google Font for UI */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">Loading Game...</div>
        <div id="loading-progress">0%</div>
    </div>
    <div id="container"></div>
    <div id="ui-container">
        <div id="score">Score: 0</div>
        <div id="distance">Distance: 0 m</div>
    </div>
    <div id="game-over">
        <div id="game-over-text"></div>
        <button id="restart-button">Restart</button>
    </div>
    <div id="pause-screen"
        style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 4em; text-shadow: 2px 2px 5px black; z-index: 102;">
        PAUSED</div>
    <div id="alert-message">⚠️ SLOW DOWN! PEDESTRIANS CROSSING ⚠️</div>
    <div id="overspeed-alert">⚠️ OVERSPEEDING! SLOW DOWN! ⚠️</div>
    <div id="pause-button" class="control-button"
        style="left: 50%; transform: translateX(-50%); bottom: 120px; font-size: 1.2em;">
        ⏸
    </div>
    <div id="racing-lines"></div>
    <div id="speedometer-container">
        <div id="speedometer-content">
            <div id="speedometer-label">MUSTANG</div>
            <div id="speedometer-needle"></div>
            <div id="speed-value">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
    </div>
    <div id="left-button" class="control-button">◀</div>
    <div id="right-button" class="control-button">▶</div>
    <!-- Audio Elements -->
    <audio id="acceleration-sound" preload="auto">
        <source src="c:\Users\ASUS\Desktop\car sounds.mpeg" type="audio/mpeg">
    </audio>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js'; // For HDRI
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        let scene, camera, renderer, carModel, enemyCar;
        let ambientLight, directionalLight;
        let road, roadLines = [], kerbs = [];
        let buildings = [], streetLights = [], trafficLights = [], zebracrossings = [], pedestrians = [];
        let zebraCrossingTrafficLights = [];
        let stars = [], moon;
        const roadWidth = 10;
        const roadLength = 200; // Visible length of the road
        const sceneryRecycleDistance = roadLength / 2; // Distance to recycle scenery elements
        const buildingSpacing = 15;
        const lightSpacing = 30;
        const numBuildings = Math.floor(roadLength * 1.5 / buildingSpacing); // Spawn more buildings to cover recycle distance
        const numLights = Math.floor(roadLength * 1.5 / lightSpacing);
        let currentSpeed = 0.5; // Scenery scroll speed (player's effective forward speed)
        const minSpeed = 0.0;
        const maxSpeed = 2.0;
        const acceleration = 0.02;
        const enemyCarSpeed = 0.6; // Enemy moves faster relative to scenery scroll
        const kerbHeight = 0.2;
        const kerbWidth = 0.3;
        // --- Game State ---
        let moveLeft = false;
        let moveRight = false;
        let isBraking = false;
        const carMoveSpeed = 0.15; // How fast the player car moves left/right
        let carBaseY = 0; // Will be calculated based on car model bounding box
        let score = 0;
        let distance = 0;
        let isGameOver = false;
        let isPaused = false;
        let zebraCrossingPedestrians = [];
        let alertMessageActive = false;
        let overspeedAlertActive = false;
        // --- Day/Night Cycle ---
        let dayNightCycleTime = 0;
        const dayNightCycleDuration = 120; // 2 minutes in seconds
        let timeElapsed = 0;
        // --- End Day/Night Cycle ---
        // --- Points ---
        const points = [];
        const numPoints = 15;
        const pointValue = 10;
        let pointGeometry, pointMaterial;
        const pointRadius = 0.3;
        // --- End Points ---
        // --- Traffic Light State ---
        let trafficLightTime = 0;
        const trafficLightCycleDuration = 8; // 8 seconds cycle (4 red, 4 green)
        // --- End Traffic Light State ---
        // --- UI Elements References ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');
        const scoreElement = document.getElementById('score');
        const distanceElement = document.getElementById('distance');
        const gameOverElement = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const pauseButton = document.getElementById('pause-button');
        const gameOverText = document.getElementById('game-over-text');
        const alertMessage = document.getElementById('alert-message');
        const overspeedAlert = document.getElementById('overspeed-alert');
        const accelerationSound = document.getElementById('acceleration-sound');
        let isAccelerating = false;
        const speedometerNeedle = document.getElementById('speedometer-needle');
        const speedValue = document.getElementById('speed-value');
        const racingLinesContainer = document.getElementById('racing-lines');
        const gameOverMessages = [
            "In the game, you restart. In life, you remain a memory.",
            "The faster you go, the less time you have to say goodbye.",
            "Your family is waiting at the finish line. Don't stop halfway.",
            "Better to arrive late than to never arrive at all."
        ];
        // --- End UI Refs ---
        // --- Bounding Boxes (for collision detection) ---
        let playerBox = new THREE.Box3();
        let enemyBox = new THREE.Box3();
        let pointBox = new THREE.Box3();
        // --- End Bounding Boxes ---
        const loadingManager = new THREE.LoadingManager();
        // Loading Manager Callbacks
        loadingManager.onLoad = () => {
            console.log("All resources loaded!");
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                if (loadingScreen) loadingScreen.style.display = 'none';
                // Start game loop after loading screen fades
                if (!isGameOver) animate(); // Ensure animate starts only once after loading
            }, 600);
        };
        loadingManager.onError = (url) => {
            console.error(`There was an error loading ${url}`);
            loadingScreen.textContent = `Error loading: ${url}. Check console.`;
            loadingScreen.classList.remove('hidden');
            loadingScreen.style.opacity = 1;
        };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = Math.round((itemsLoaded / itemsTotal) * 100);
            loadingProgress.textContent = `${progress}%`;
        };
        init(); // Initialize the scene and elements
        setupControls(); // Set up both keyboard and touch controls
        // animate() will be called by loadingManager.onLoad after everything is ready.
        function init() {
            // --- Basic Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6); // Default background before HDRI
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9); // Fog for depth
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial camera position (will be adjusted after car model loads)
            camera.position.set(0, 3, -7);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // For PBR realism
            renderer.toneMappingExposure = 1.2; // Adjust exposure for HDRI
            document.getElementById('container').appendChild(renderer.domElement);
            // --- Lights ---
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Softer ambient light
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Main light (sun)
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Target for directional light
            // --- Stars and Moon Setup ---
            // Create stars
            const starGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const numStars = 100;
            for (let i = 0; i < numStars; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 50;
                const height = 20 + Math.random() * 60;
                star.position.set(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );
                star.visible = false; // Hidden during day
                stars.push(star);
                scene.add(star);
            }
            // Create moon
            const moonGeometry = new THREE.SphereGeometry(8, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(40, 60, -100); // Position in the sky
            moon.visible = false; // Hidden during day
            scene.add(moon);
            // --- HDRI Environment Map ---
            // Using a common HDRI from Three.js examples (adjust path/name if you have your own)
            const hdrPath = 'https://threejs.org/examples/textures/equirectangular/';
            const hdrName = 'venice_sunset_1k.hdr'; // Or 'royal_esplanade_1k.hdr', 'memorial_park_1k.hdr'
            new RGBELoader(loadingManager) // Use loadingManager
                .setPath(hdrPath)
                .load(hdrName, function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; // Apply to reflective materials
                    scene.background = texture; // Use as background
                }, undefined, (error) => {
                    console.error('Error loading HDRI:', error);
                    scene.background = new THREE.Color(0xa0d7e6); // Fallback to solid color
                });
            // --- Ground, Road, Lines, Kerbs ---
            const groundGeo = new THREE.PlaneGeometry(roadWidth * 5, roadLength * 1.5); // Wider ground
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);
            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength * 1.5); // Longer road for smooth scrolling
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 }); // Darker, slightly reflective asphalt
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.0;
            road.receiveShadow = true;
            scene.add(road);
            const lineLength = 4;
            const lineGap = 4;
            const numLines = Math.floor(roadLength * 1.5 / (lineLength + lineGap)); // More lines
            const lineGeo = new THREE.PlaneGeometry(0.3, lineLength);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.2, metalness: 0.0 });
            for (let i = 0; i < numLines; i++) {
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.y = 0.005; // Slightly above road to prevent Z-fighting
                line.position.z = (roadLength * 1.5 / 2) - (lineLength / 2) - i * (lineLength + lineGap);
                line.receiveShadow = true;
                roadLines.push(line);
                scene.add(line);
            }
            function createKerbTexture() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 16;
                const stripeWidth = 8;
                const colors = ['#ff0000', '#ffffff'];
                for (let i = 0; i < canvas.width / stripeWidth; i++) {
                    ctx.fillStyle = colors[i % 2];
                    ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height);
                }
                return new THREE.CanvasTexture(canvas);
            }
            const kerbTexture = createKerbTexture();
            kerbTexture.wrapS = THREE.RepeatWrapping;
            kerbTexture.wrapT = THREE.ClampToEdgeWrapping;
            kerbTexture.repeat.set(roadLength * 1.5 / 4, 1); // Repeat over longer road
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength * 1.5);
            const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture, roughness: 0.7, metalness: 0.1 });
            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMat);
            kerbLeft.position.set(-(roadWidth / 2) - (kerbWidth / 2), kerbHeight / 2, 0);
            kerbLeft.castShadow = true;
            kerbLeft.receiveShadow = true;
            scene.add(kerbLeft);
            kerbs.push(kerbLeft);
            const kerbRight = new THREE.Mesh(kerbGeo, kerbMat);
            kerbRight.position.set((roadWidth / 2) + (kerbWidth / 2), kerbHeight / 2, 0);
            kerbRight.castShadow = true;
            kerbRight.receiveShadow = true;
            scene.add(kerbRight);
            kerbs.push(kerbRight);
            // --- Buildings, Street Lights, Traffic Lights ---
            function createBuilding() {
                const height = Math.random() * 30 + 10;
                const width = Math.random() * 8 + 4;
                const depth = Math.random() * 8 + 4;
                const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                const buildingMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2), // Grayscale-ish colors
                    roughness: 0.8,
                    metalness: 0.1
                });
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.y = height / 2;
                building.castShadow = true;
                building.receiveShadow = true;
                return building;
            }
            for (let i = 0; i < numBuildings; i++) {
                const buildingLeft = createBuilding();
                const buildingRight = createBuilding();
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - i * buildingSpacing;
                const xOffsetLeft = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingLeft.geometry.parameters.width / 2;
                const xOffsetRight = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingRight.geometry.parameters.width / 2;
                buildingLeft.position.set(-xOffsetLeft, buildingLeft.position.y, zPos);
                buildingRight.position.set(xOffsetRight, buildingRight.position.y, zPos);
                buildings.push(buildingLeft, buildingRight);
                scene.add(buildingLeft);
                scene.add(buildingRight);
            }
            function createStreetLight() {
                const group = new THREE.Group();
                const poleHeight = 6;
                const poleRadius = 0.1;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.castShadow = true;
                pole.position.y = poleHeight / 2;
                group.add(pole);
                const armLength = 1.5; // Longer arm
                const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.5, poleRadius * 1.5);
                const arm = new THREE.Mesh(armGeo, poleMat);
                arm.position.set(0, poleHeight - poleRadius * 2, 0); // Position arm correctly
                group.add(arm);
                const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2, 16, 8);
                const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffff00, emissiveIntensity: 0.5 });
                const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat);
                lightFixture.position.set(0, poleHeight - poleRadius * 2, 0); // Position fixture correctly
                group.add(lightFixture);
                group.userData.armLength = armLength; // Store for positioning later
                return group;
            }
            for (let i = 0; i < numLights; i++) {
                const lightLeft = createStreetLight();
                const lightRight = createStreetLight();
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - i * lightSpacing;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;
                lightLeft.position.set(-xPos, 0, zPos);
                lightLeft.rotation.y = Math.PI / 2; // Rotate to face road
                lightLeft.children[1].position.x = -lightLeft.userData.armLength / 2; // Arm extends inwards
                lightLeft.children[2].position.x = -lightLeft.userData.armLength; // Light at end of arm
                streetLights.push(lightLeft);
                scene.add(lightLeft);
                lightRight.position.set(xPos, 0, zPos);
                lightRight.rotation.y = -Math.PI / 2; // Rotate to face road
                lightRight.children[1].position.x = -lightRight.userData.armLength / 2; // Arm extends inwards
                lightRight.children[2].position.x = -lightRight.userData.armLength; // Light at end of arm
                streetLights.push(lightRight);
                scene.add(lightRight);
            }
            function createTrafficLight() {
                const group = new THREE.Group();
                const poleHeight = 5;
                const poleRadius = 0.15;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.5 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.y = poleHeight / 2;
                pole.castShadow = true;
                group.add(pole);
                const housingWidth = 0.5;
                const housingHeight = 1.2;
                const housingDepth = 0.3;
                const housingGeo = new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth);
                const housingMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const housing = new THREE.Mesh(housingGeo, housingMat);
                housing.position.y = poleHeight - housingHeight / 2;
                housing.castShadow = true;
                group.add(housing);
                const lightRadius = housingWidth * 0.25;
                const lightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
                const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 });
                const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 1 });
                const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 1 });
                const redLight = new THREE.Mesh(lightGeo, redMat); redLight.position.set(0, housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(redLight);
                const yellowLight = new THREE.Mesh(lightGeo, yellowMat); yellowLight.position.set(0, 0, housingDepth / 2 + 0.01); housing.add(yellowLight);
                const greenLight = new THREE.Mesh(lightGeo, greenMat); greenLight.position.set(0, -housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(greenLight);
                return group;
            }
            // Only one traffic light in view for now, more can be added later as a loop
            const trafficLightLeft = createTrafficLight();
            const trafficLightRight = createTrafficLight();
            const trafficLightZ = roadLength * 0.4;
            const trafficLightX = roadWidth / 2 + kerbWidth + 0.5;
            trafficLightLeft.position.set(-trafficLightX, 0, trafficLightZ);
            trafficLightLeft.rotation.y = Math.PI / 2;
            trafficLightRight.position.set(trafficLightX, 0, trafficLightZ);
            trafficLightRight.rotation.y = -Math.PI / 2;
            trafficLights.push(trafficLightLeft, trafficLightRight);
            scene.add(trafficLightLeft);
            scene.add(trafficLightRight);
            // --- Zebra Crossing Setup ---
            function createZebraCrossing() {
                const group = new THREE.Group();
                const stripeWidth = 0.4;
                const stripeLength = roadWidth;
                const numStripes = 10;
                const spacing = 0.3;
                for (let i = 0; i < numStripes; i++) {
                    const stripeGeo = new THREE.PlaneGeometry(stripeLength, stripeWidth);
                    const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.5, metalness: 0.0 });
                    const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                    stripe.rotation.x = -Math.PI / 2;
                    stripe.position.y = 0.01; // Slightly above road
                    stripe.position.z = (i - numStripes / 2) * (stripeWidth + spacing);
                    stripe.receiveShadow = true;
                    group.add(stripe);
                }
                return group;
            }
            const zebraCrossingInterval = 1500; // Interval in meters
            const numZebraCrossings = Math.ceil(roadLength * 1.5 / zebraCrossingInterval) + 2;
            for (let i = 0; i < numZebraCrossings; i++) {
                const zebraCrossing = createZebraCrossing();
                const zPos = (roadLength * 1.5 / 2) - i * zebraCrossingInterval;
                zebraCrossing.position.z = zPos;
                zebracrossings.push(zebraCrossing);
                scene.add(zebraCrossing);
            }
            // --- Traffic Lights at Zebra Crossings ---
            function createZebraTrafficLight() {
                const group = new THREE.Group();
                const poleHeight = 6;
                const poleRadius = 0.15;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7, roughness: 0.5 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.y = poleHeight / 2;
                pole.castShadow = true;
                group.add(pole);
                const housingWidth = 0.5;
                const housingHeight = 1.2;
                const housingDepth = 0.3;
                const housingGeo = new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth);
                const housingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const housing = new THREE.Mesh(housingGeo, housingMat);
                housing.position.y = poleHeight - housingHeight / 2;
                housing.castShadow = true;
                group.add(housing);
                const lightRadius = housingWidth * 0.25;
                const lightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
                const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 });
                const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 1 });
                const redLight = new THREE.Mesh(lightGeo, redMat);
                redLight.position.set(0, housingHeight * 0.3, housingDepth / 2 + 0.01);
                housing.add(redLight);
                group.redLight = redLight;
                const greenLight = new THREE.Mesh(lightGeo, greenMat);
                greenLight.position.set(0, -housingHeight * 0.3, housingDepth / 2 + 0.01);
                housing.add(greenLight);
                group.greenLight = greenLight;
                return group;
            }
            for (let i = 0; i < numZebraCrossings; i++) {
                const trafficLightLeft = createZebraTrafficLight();
                const trafficLightRight = createZebraTrafficLight();
                const zPos = (roadLength * 1.5 / 2) - i * zebraCrossingInterval;
                const xPos = roadWidth / 2 + kerbWidth + 0.5;
                trafficLightLeft.position.set(-xPos, 0, zPos);
                trafficLightLeft.rotation.y = Math.PI / 2;
                zebraCrossingTrafficLights.push(trafficLightLeft);
                scene.add(trafficLightLeft);
                trafficLightRight.position.set(xPos, 0, zPos);
                trafficLightRight.rotation.y = -Math.PI / 2;
                zebraCrossingTrafficLights.push(trafficLightRight);
                scene.add(trafficLightRight);
            }
            // --- Zebra Crossing Pedestrians Setup ---
            function createZebraPedestrian() {
                const group = new THREE.Group();
                // Head
                const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6, metalness: 0.0 });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.7;
                group.add(head);
                // Body
                const bodyGeo = new THREE.BoxGeometry(0.4, 0.8, 0.25);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.7, metalness: 0.1 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1.1;
                group.add(body);
                // Left Arm
                const armGeo = new THREE.BoxGeometry(0.15, 0.7, 0.15);
                const armMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6, metalness: 0.0 });
                const leftArm = new THREE.Mesh(armGeo, armMat);
                leftArm.position.set(-0.3, 1.2, 0);
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeo, armMat);
                rightArm.position.set(0.3, 1.2, 0);
                group.add(rightArm);
                // Left Leg
                const legGeo = new THREE.BoxGeometry(0.15, 0.7, 0.15);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 });
                const leftLeg = new THREE.Mesh(legGeo, legMat);
                leftLeg.position.set(-0.15, 0.35, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, legMat);
                rightLeg.position.set(0.15, 0.35, 0);
                group.add(rightLeg);
                group.leftArm = leftArm;
                group.rightArm = rightArm;
                group.leftLeg = leftLeg;
                group.rightLeg = rightLeg;
                group.walkCycle = 0;
                group.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                return group;
            }
            // Create pedestrians on each zebra crossing
            for (let i = 0; i < numZebraCrossings; i++) {
                for (let j = 0; j < 2; j++) { // 2 pedestrians per zebra crossing
                    const pedestrian = createZebraPedestrian();
                    const crossingZ = (roadLength * 1.5 / 2) - i * zebraCrossingInterval;
                    // Pedestrians start from footpath on one side and cross to the other side
                    const startSide = j === 0 ? -1 : 1; // -1 for left footpath, +1 for right footpath
                    const startX = startSide * (roadWidth / 2 + 2); // Start on footpath (2 units beyond road edge)
                    pedestrian.position.set(startX, 0, crossingZ);
                    pedestrian.userData.crossingZ = crossingZ;
                    pedestrian.userData.isOnZebraCrossing = true;
                    pedestrian.userData.crossDirection = startSide; // Direction away from starting side
                    pedestrian.userData.crossingProgress = 0; // Start from footpath
                    pedestrian.userData.crossSpeed = 0.3; // Slower crossing speed
                    pedestrian.userData.roadWidth = roadWidth;
                    pedestrian.userData.footpathOffset = 2; // Distance from road edge to start position
                    zebraCrossingPedestrians.push(pedestrian);
                    scene.add(pedestrian);
                }
            }
            // --- Points Setup ---
            pointGeometry = new THREE.SphereGeometry(pointRadius, 16, 16); // More segments for smoother look
            pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 0.8, metalness: 0.9, roughness: 0.1 });
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.castShadow = true;
                point.receiveShadow = true;
                resetPointPosition(point, true); // initial positions spread out
                points.push(point);
                scene.add(point);
            }
            // --- Car Model Loading ---
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);
            // Official Ferrari GLB URL
            const carUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';
            loader.load(carUrl, (gltf) => {
                carModel = gltf.scene;
                carModel.scale.set(0.8, 0.8, 0.8); // Scale down for scene
                const box = new THREE.Box3().setFromObject(carModel);
                carBaseY = -box.min.y + 0.01; // Adjust Y to sit on road
                carModel.position.set(0, carBaseY, 0);
                carModel.rotation.y = Math.PI; // Face forward
                carModel.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // For PBR materials like in Ferrari model, environment map is key
                        // Materials are generally MeshPhysicalMaterial
                    }
                });
                scene.add(carModel);
                // --- Enemy Car Setup (Clone Player Car) ---
                enemyCar = carModel.clone();
                enemyCar.traverse((node) => {
                    if (node.isMesh) {
                        // Create a distinct material for the enemy car (e.g., metallic blue)
                        const originalMaterial = node.material;
                        const enemyMaterial = originalMaterial.clone();
                        enemyMaterial.color.setHex(0x0000ff); // Set to blue
                        enemyMaterial.metalness = 0.9;
                        enemyMaterial.roughness = 0.2;
                        node.material = enemyMaterial;
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7); // Spawn further down the road
                enemyCar.rotation.y = Math.PI; // Face forward initially, will be reversed for oncoming
                scene.add(enemyCar);
                console.log("Enemy car added and colored blue");
                // Set initial Camera position AFTER carModel is loaded and carBaseY is known
                camera.position.set(0, carBaseY + 3, -7);
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
            }, undefined, (error) => {
                // Fallback for car model loading failure
                console.error('An error happened loading the car model:', error);
                const fallbackGeo = new THREE.BoxGeometry(2, 1, 4);
                const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.5 });
                carModel = new THREE.Mesh(fallbackGeo, fallbackMat);
                carBaseY = 0.5 + 0.01; // Default for fallback box
                carModel.position.set(0, carBaseY, 0);
                carModel.castShadow = true;
                carModel.receiveShadow = true;
                scene.add(carModel);
                // Fallback enemy car
                enemyCar = new THREE.Mesh(fallbackGeo, new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5, metalness: 0.5 }));
                enemyCar.position.set(roadWidth / 4, carBaseY, roadLength * 0.7);
                enemyCar.castShadow = true;
                enemyCar.receiveShadow = true;
                scene.add(enemyCar);
                camera.position.set(0, carBaseY + 3, -7);
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
                loadingScreen.textContent = 'Error loading car model. Displaying fallback.';
                loadingScreen.classList.remove('hidden');
                loadingScreen.style.opacity = 1;
            });
            // --- Restart Button Listener ---
            restartButton.addEventListener('click', restartGame);
            // --- Resize Listener ---
            window.addEventListener('resize', onWindowResize, false);
            // --- Initial Score Display ---
            updateScoreDisplay();
            updateDistanceDisplay();
        }
        // --- Function to Set Up Controls (Keyboard & Touch) ---
        function setupControls() {
            // Keyboard Listeners
            window.addEventListener('keydown', (event) => {
                if (isGameOver) return;
                if (event.key.toLowerCase() === 'a') { moveLeft = true; }
                else if (event.key.toLowerCase() === 'd') { moveRight = true; }
                else if (event.key.toLowerCase() === 'w') {
                    currentSpeed = Math.min(maxSpeed, currentSpeed + acceleration);
                    // Play acceleration sound if not already playing
                    if (!isAccelerating && accelerationSound) {
                        accelerationSound.currentTime = 0;
                        accelerationSound.play().catch(err => console.log('Audio play failed:', err));
                        isAccelerating = true;
                    }
                }
                else if (event.key.toLowerCase() === 's') { isBraking = true; }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key.toLowerCase() === 'a') { moveLeft = false; }
                else if (event.key.toLowerCase() === 'd') { moveRight = false; }
                else if (event.key.toLowerCase() === 'w') { isAccelerating = false; }
                else if (event.key.toLowerCase() === 's') { isBraking = false; }
            });
            // Touch Listeners for Buttons
            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');
            if (leftButton) {
                // Using 'pointerdown' and 'pointerup' for broader compatibility (mouse, touch, pen)
                // and to correctly handle multiple touches/gestures if needed, though 'touchstart'/'touchend' are fine for simple cases.
                leftButton.addEventListener('pointerdown', (e) => { if (!isGameOver) { e.preventDefault(); moveRight = true; } }, { passive: false });
                leftButton.addEventListener('pointerup', (e) => { e.preventDefault(); moveRight = false; });
                leftButton.addEventListener('pointerleave', (e) => { // If finger slides off button while pressed
                    if (e.pointerType === 'touch') { moveRight = false; }
                });
            }
            if (rightButton) {
                rightButton.addEventListener('pointerdown', (e) => { if (!isGameOver) { e.preventDefault(); moveLeft = true; } }, { passive: false });
                rightButton.addEventListener('pointerup', (e) => { e.preventDefault(); moveLeft = false; });
                rightButton.addEventListener('pointerleave', (e) => { // If finger slides off button while pressed
                    if (e.pointerType === 'touch') { moveLeft = false; }
                });
            }
            // --- Pause Controls ---
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'p' && !isGameOver) {
                    togglePause();
                }
            });
            if (pauseButton) {
                pauseButton.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    if (!isGameOver) togglePause();
                }, { passive: false });
            }
        }
        // --- End Setup Controls ---
        function resetPointPosition(point, initial = false) {
            const laneWidth = roadWidth / 2 - kerbWidth - pointRadius * 2;
            point.position.x = (Math.random() * 2 - 1) * laneWidth;
            point.position.y = pointRadius + 0.01;
            if (initial) {
                point.position.z = Math.random() * roadLength * 0.8 - roadLength * 0.4; // Initial spread within visible range
            } else {
                point.position.z = roadLength / 2 + Math.random() * roadLength * 0.5; // Spawn well ahead
            }
            point.visible = true;
        }
        function updateScoreDisplay() {
            scoreElement.textContent = `Score: ${score}`;
        }
        function updateDistanceDisplay() {
            distanceElement.textContent = `Distance: ${Math.floor(distance)} m`;
        }
        function updateSpeedometer() {
            // Convert currentSpeed to km/h (scale: 0.0 = 0 km/h, 2.0 = 200 km/h)
            const speedKmh = Math.round((currentSpeed) / (maxSpeed) * 200);
            speedValue.textContent = speedKmh;
            // Calculate needle rotation (0 to 180 degrees for speedometer)
            const speedPercentage = (currentSpeed) / (maxSpeed);
            const needleRotation = speedPercentage * 180 - 90; // -90 to 90 degrees
            speedometerNeedle.style.transform = `rotate(${needleRotation}deg)`;
        }
        function updateRacingLines() {
            // Convert currentSpeed to km/h
            const speedKmh = Math.round((currentSpeed - minSpeed) / (maxSpeed - minSpeed) * 180 + 20);
            if (speedKmh >= 160) {
                // Show racing lines
                racingLinesContainer.style.display = 'block';
                // Create new racing line if random chance
                if (Math.random() < 0.3) {
                    const line = document.createElement('div');
                    line.className = 'racing-line';
                    const x = Math.random() * window.innerWidth;
                    const width = 2 + Math.random() * 3;
                    const height = 40 + Math.random() * 60;
                    line.style.left = x + 'px';
                    line.style.top = '-10px';
                    line.style.width = width + 'px';
                    line.style.height = height + 'px';
                    racingLinesContainer.appendChild(line);
                    // Remove line after animation completes
                    setTimeout(() => {
                        line.remove();
                    }, 600);
                }
            } else {
                // Hide racing lines
                racingLinesContainer.style.display = 'none';
                // Clear all racing lines
                racingLinesContainer.innerHTML = '';
            }
        }
        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'block' : 'none';
            if (isPaused) {
                pauseButton.textContent = '▶';
            }
            else {
                pauseButton.textContent = '⏸';
            }
        }
        function updateDayNightCycle() {
            // Calculate position in cycle (0 to 1)
            const cyclePosition = (dayNightCycleTime % dayNightCycleDuration) / dayNightCycleDuration;
            // Define day/night phases
            let ambientIntensity, directionalIntensity, bgColor, fogColor;
            if (cyclePosition < 0.25) {
                // Sunrise (0-30 sec)
                const t = cyclePosition / 0.25;
                ambientIntensity = 0.2 + t * 0.4; // 0.2 to 0.6
                directionalIntensity = 0.5 + t * 1.0; // 0.5 to 1.5
                bgColor = new THREE.Color().lerpColors(new THREE.Color(0x1a1a2e), new THREE.Color(0xa0d7e6), t);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x1a1a2e), new THREE.Color(0xa0d7e6), t);
            } else if (cyclePosition < 0.5) {
                // Day (30-60 sec)
                const t = (cyclePosition - 0.25) / 0.25;
                ambientIntensity = 0.6;
                directionalIntensity = 1.5;
                bgColor = new THREE.Color(0xa0d7e6);
                fogColor = new THREE.Color(0xa0d7e6);
            } else if (cyclePosition < 0.75) {
                // Sunset (60-90 sec)
                const t = (cyclePosition - 0.5) / 0.25;
                ambientIntensity = 0.6 - t * 0.4; // 0.6 to 0.2
                directionalIntensity = 1.5 - t * 1.0; // 1.5 to 0.5
                bgColor = new THREE.Color().lerpColors(new THREE.Color(0xa0d7e6), new THREE.Color(0xff6b35), t);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0xa0d7e6), new THREE.Color(0xff6b35), t);
            } else {
                // Night (90-120 sec)
                const t = (cyclePosition - 0.75) / 0.25;
                ambientIntensity = 0.2 - t * 0.1; // 0.2 to 0.1
                directionalIntensity = 0.5 - t * 0.3; // 0.5 to 0.2
                bgColor = new THREE.Color().lerpColors(new THREE.Color(0xff6b35), new THREE.Color(0x1a1a2e), t);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0xff6b35), new THREE.Color(0x1a1a2e), t);
            }
            // Update lighting
            ambientLight.intensity = ambientIntensity;
            directionalLight.intensity = directionalIntensity;
            scene.background = bgColor;
            scene.fog.color = fogColor;
            // Street lights glow more at night
            const streetLightIntensity = 1 - ambientIntensity;
            streetLights.forEach(light => {
                light.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissiveIntensity = streetLightIntensity * 0.8;
                    }
                });
            });
            // Show/hide stars and moon based on cycle phase
            let starsOpacity = 0;
            let moonOpacity = 0;
            if (cyclePosition >= 0.5 && cyclePosition < 0.75) {
                // Sunset - fade in stars and moon
                starsOpacity = (cyclePosition - 0.5) / 0.25;
                moonOpacity = (cyclePosition - 0.5) / 0.25;
            } else if (cyclePosition >= 0.75) {
                // Night - full stars and moon
                starsOpacity = 1;
                moonOpacity = 1;
            } else if (cyclePosition < 0.25) {
                // Sunrise - fade out stars and moon
                starsOpacity = 1 - (cyclePosition / 0.25);
                moonOpacity = 1 - (cyclePosition / 0.25);
            }
            // Update star visibility
            stars.forEach(star => {
                star.visible = starsOpacity > 0;
                if (star.material.opacity !== undefined) {
                    star.material.opacity = starsOpacity;
                }
            });
            // Update moon visibility
            if (moon) {
                moon.visible = moonOpacity > 0;
                if (moon.material.opacity !== undefined) {
                    moon.material.opacity = moonOpacity;
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate); // IMPORTANT: This creates the continuous game loop
            if (isGameOver) {
                renderer.render(scene, camera);
                return; // Stop game logic updates if game over
            }
            if (isPaused) {
                renderer.render(scene, camera);
                return; // Render but don't update game logic
            }
            // --- Update Day/Night Cycle ---
            dayNightCycleTime += 0.016; // ~60 FPS, so ~0.016 seconds per frame
            updateDayNightCycle();
            // --- Update Traffic Lights ---
            trafficLightTime += 0.016;
            const trafficLightCyclePosition = trafficLightTime % trafficLightCycleDuration;
            const isGreen = trafficLightCyclePosition >= 4; // First 4 seconds = red, next 4 = green
            zebraCrossingTrafficLights.forEach(light => {
                if (isGreen) {
                    light.greenLight.material.emissiveIntensity = 1;
                    light.redLight.material.emissiveIntensity = 0.2;
                } else {
                    light.redLight.material.emissiveIntensity = 1;
                    light.greenLight.material.emissiveIntensity = 0.2;
                }
            });
            // --- Braking Logic ---
            if (isBraking) {
                currentSpeed = Math.max(minSpeed, currentSpeed - acceleration);
            }
            const deltaZ = currentSpeed;
            // --- Scenery Movement and Recycling ---
            roadLines.forEach(line => {
                line.position.z -= deltaZ;
                if (line.position.z < -sceneryRecycleDistance) {
                    line.position.z += roadLength * 1.5; // Loop the lines
                }
            });
            buildings.forEach(building => {
                building.position.z -= deltaZ;
                if (building.position.z < -sceneryRecycleDistance - building.geometry.parameters.depth / 2) {
                    const sideSign = Math.sign(building.position.x);
                    const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                    building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, roadLength * 1.5 / 2 + Math.random() * buildingSpacing * 2);
                }
            });
            streetLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.8;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * lightSpacing * 2);
                }
            });
            trafficLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.5;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * roadLength * 0.5); // Spawn further out
                }
            });
            zebracrossings.forEach(zebraCrossing => {
                zebraCrossing.position.z -= deltaZ;
                if (zebraCrossing.position.z < -sceneryRecycleDistance) {
                    zebraCrossing.position.z += roadLength * 1.5; // Loop the zebra crossings
                }
            });
            kerbs.forEach(kerb => {
                kerb.position.z -= deltaZ;
                if (kerb.position.z < -sceneryRecycleDistance) {
                    kerb.position.z += roadLength * 1.5;
                }
            });
            // --- Move and Animate Zebra Crossing Pedestrians ---
            zebraCrossingPedestrians.forEach(pedestrian => {
                // Move pedestrians with the road (backward)
                pedestrian.position.z -= deltaZ;
                // Animate pedestrian crossing the road
                pedestrian.userData.crossingProgress += pedestrian.userData.crossSpeed * 0.005; // Progression of crossing
                
                // Calculate crossing path: from footpath on one side to footpath on the other side
                const footpathOffset = pedestrian.userData.footpathOffset;
                const roadWidth = pedestrian.userData.roadWidth;
                const totalCrossingDistance = roadWidth + 2 * footpathOffset; // From one footpath to other
                
                // Starting position: one side of footpath
                const startX = -pedestrian.userData.crossDirection * (roadWidth / 2 + footpathOffset);
                // Ending position: other side of footpath
                const endX = pedestrian.userData.crossDirection * (roadWidth / 2 + footpathOffset);
                
                // Move across based on progress (0 to 1)
                pedestrian.position.x = startX + (endX - startX) * Math.min(pedestrian.userData.crossingProgress, 1);
                
                // Walking animation
                pedestrian.walkCycle = (pedestrian.walkCycle || 0) + 0.05;
                const walkAmount = Math.sin(pedestrian.walkCycle) * 0.15;
                pedestrian.leftArm.rotation.z = walkAmount * 0.5;
                pedestrian.rightArm.rotation.z = -walkAmount * 0.5;
                pedestrian.leftLeg.rotation.x = walkAmount * 0.3;
                pedestrian.rightLeg.rotation.x = -walkAmount * 0.3;
                
                // Reset when crossing is complete
                if (pedestrian.userData.crossingProgress >= 1) {
                    pedestrian.userData.crossingProgress = 0;
                }
                
                // Recycle pedestrians
                if (pedestrian.position.z < -sceneryRecycleDistance) {
                    pedestrian.position.z = pedestrian.userData.crossingZ + roadLength * 1.5;
                    pedestrian.userData.crossingProgress = 0;
                    pedestrian.walkCycle = 0;
                }
            });
            // --- Move and Recycle Points ---
            points.forEach(point => {
                if (!point.visible) return; // Only move visible points
                point.position.z -= deltaZ;
                point.rotation.y += 0.05; // Coin rotation
                if (point.position.z < -sceneryRecycleDistance) {
                    resetPointPosition(point);
                }
            });
            // --- Move Enemy Car ---
            if (enemyCar && carModel) { // Ensure both are loaded
                // Enemy car moves forward relative to world, while road scrolls towards player.
                // This creates the illusion of the enemy coming towards the player.
                enemyCar.position.z -= (currentSpeed + 0.1); // Sum of own speed and road scroll speed
                if (enemyCar.position.z < -sceneryRecycleDistance) { // Recycle when it passes player
                    enemyCar.position.z = roadLength * 0.7 + Math.random() * roadLength * 0.5; // Spawn well ahead
                    enemyCar.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 - kerbWidth - 1); // Random lane
                    enemyCar.rotation.y = Math.PI; // Ensure it's facing forward
                }
            }
            // --- Handle Player Car Controls & Update Bounding Box ---
            if (carModel && carBaseY > 0) { // Ensure car model is loaded and positioned
                let maxBounds = roadWidth / 2 - kerbWidth - 0.1; // Default fallback bounds
                let carHalfWidth = 1; // Default fallback for car width
                try {
                    const box = new THREE.Box3().setFromObject(carModel);
                    carHalfWidth = (box.max.x - box.min.x) / 2;
                    maxBounds = (roadWidth / 2) - kerbWidth - carHalfWidth - 0.1;
                } catch (e) {
                    // console.warn("Could not get car bounding box size, using default bounds.");
                }
                if (moveLeft && carModel.position.x > -maxBounds) { carModel.position.x -= carMoveSpeed; }
                if (moveRight && carModel.position.x < maxBounds) { carModel.position.x += carMoveSpeed; }
                carModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, carModel.position.x));
                playerBox.setFromObject(carModel); // Always update player's bounding box
            }
            // --- Traffic Light Stop Logic ---
            if (carModel && !isGreen) {
                // Check if car is near any red traffic light
                let nearRedLight = false;
                zebraCrossingTrafficLights.forEach(light => {
                    const distanceToCrossing = carModel.position.distanceTo(light.position);
                    if (distanceToCrossing < 20) {
                        nearRedLight = true;
                    }
                });
                // Force car to slow down at red light
                if (nearRedLight && currentSpeed > minSpeed) {
                    currentSpeed = Math.max(currentSpeed - 0.08, minSpeed); // Force deceleration
                }
            }
            // --- Update Camera (smooth follow) ---
            if (carModel) {
                const targetCameraX = carModel.position.x * 0.5; // Camera follows less drastically than car
                camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
            }
            // --- Collision Detection ---
            if (carModel) {
                // Point Collision
                points.forEach(point => {
                    if (!point.visible) return;
                    pointBox.setFromObject(point);
                    if (playerBox.intersectsBox(pointBox)) {
                        score += pointValue;
                        updateScoreDisplay();
                        point.visible = false; // Make point disappear
                    }
                });
                // Enemy Collision
                if (enemyCar && enemyCar.parent) { // Ensure enemyCar is in scene
                    enemyBox.setFromObject(enemyCar);
                    // Use a slightly larger collision box for player for easier hits or vice versa
                    const expandedPlayerBox = playerBox.clone().expandByScalar(0.5); // Increase player car's collision area slightly
                    if (expandedPlayerBox.intersectsBox(enemyBox)) {
                        console.log("Collision with enemy!");
                        isGameOver = true;
                        gameOverText.textContent = gameOverMessages[Math.floor(Math.random() * gameOverMessages.length)];
                        gameOverElement.style.display = 'flex'; // Show game over screen
                    }
                }
                // Zebra Crossing Pedestrian Collision & Alert
                let pedestrianNearby = false;
                // Calculate minimum speed threshold (25 km/h)
                const minSpeedKmh = 25;
                const speedThreshold = (minSpeedKmh - 20) / 180 * (maxSpeed - minSpeed) + minSpeed;
                zebraCrossingPedestrians.forEach(pedestrian => {
                    const pedestrianBox = new THREE.Box3().setFromObject(pedestrian);
                    const expandedPlayerBox = playerBox.clone().expandByScalar(0.5);
                    // Check proximity (alert distance)
                    const distanceToPedestrian = carModel.position.distanceTo(pedestrian.position);
                    if (distanceToPedestrian < 15) {
                        pedestrianNearby = true;
                    }
                    // Check collision - only game over if speed is above 25 km/h
                    if (expandedPlayerBox.intersectsBox(pedestrianBox)) {
                        if (currentSpeed > speedThreshold) {
                            console.log("Collision with pedestrian at high speed! Restarting...");
                            restartGame(); // Restart the game instead of showing game over
                        } else {
                            console.log("Slow collision with pedestrian - safe!");
                        }
                    }
                });
                // Show/hide alert message
                if (pedestrianNearby && !alertMessageActive) {
                    alertMessage.style.display = 'flex';
                    alertMessageActive = true;
                } else if (!pedestrianNearby && alertMessageActive) {
                    alertMessage.style.display = 'none';
                    alertMessageActive = false;
                }
            }
            // Check for overspeed alert (speed > 80 km/h)
            const speedKmh = Math.round((currentSpeed) / (maxSpeed) * 200);
            if (speedKmh > 80) {
                if (!overspeedAlertActive) {
                    overspeedAlert.style.display = 'block';
                    overspeedAlertActive = true;
                }
            } else {
                if (overspeedAlertActive) {
                    overspeedAlert.style.display = 'none';
                    overspeedAlertActive = false;
                }
            }
            // Update distance
            distance += currentSpeed;
            updateDistanceDisplay();
            updateSpeedometer();
            
            // Stop acceleration sound when car comes to a complete stop
            if (currentSpeed <= minSpeed && accelerationSound && !accelerationSound.paused) {
                accelerationSound.pause();
                accelerationSound.currentTime = 0;
            }
            
            // --- Render ---
            renderer.render(scene, camera);
        }
        function restartGame() {
            // Reset game state
            isGameOver = false;
            score = 0;
            distance = 0;
            currentSpeed = 0.5;
            dayNightCycleTime = 0; // Reset day/night cycle
            updateScoreDisplay();
            updateDistanceDisplay();
            gameOverElement.style.display = 'none';
            alertMessage.style.display = 'none';
            alertMessageActive = false;
            overspeedAlert.style.display = 'none';
            overspeedAlertActive = false;
            // Reset player car position
            if (carModel) {
                carModel.position.set(0, carBaseY, 0);
            }
            // Reset enemy car position
            if (enemyCar) {
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7);
            }
            // Reset points
            points.forEach(point => resetPointPosition(point, true));
            // Reset scenery positions (optional, they will naturally loop back)
            // Re-initializing positions for a "fresh" start visual.
            roadLines.forEach((line, i) => { line.position.z = (roadLength * 1.5 / 2) - (line.geometry.parameters.height / 2) - i * (line.geometry.parameters.height + 4); });
            buildings.forEach((building, i) => {
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - (i % (numBuildings / 2)) * buildingSpacing; // Recalculate based on original distribution
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, zPos);
            });
            streetLights.forEach((light, i) => {
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - (i % (numLights / 2)) * lightSpacing;
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;
                light.position.set(sideSign * xPos, 0, zPos);
            });
            trafficLights.forEach((light, i) => {
                const zPos = roadLength * 0.4; // Fixed traffic light
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.5;
                light.position.set(sideSign * xPos, 0, zPos);
            });
            // The animate loop is continuously running, so no need to call it again.
            // Just setting isGameOver to false will resume game logic.
        }
    </script>
</body>
</html>